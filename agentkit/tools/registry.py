from typing import Dict, Optional, Type
# Removed incorrect import of AbstractMethodError
from agentkit.tools.interface import ToolInterface
from agentkit.core.models import ToolDefinition # Using this for structure consistency

# Simple in-memory storage for available tools
# Key: Tool Name (string), Value: Tool Class (Type[ToolInterface]) or instance
# Storing the class allows for instantiation per request if needed,
# or store instances if they are stateless and reusable. Let's store classes for now.
_tool_registry: Dict[str, Type[ToolInterface]] = {}
_tool_definitions: Dict[str, ToolDefinition] = {} # Store definitions separately for quick lookup

class ToolRegistry:
    """Manages the registration and retrieval of available tools."""

    def register_tool(self, tool_class: Type[ToolInterface]) -> None:
        """
        Registers a tool class.

        Retrieves the tool definition using get_definition() and stores both
        the class and its definition.

        Args:
            tool_class: The class implementing ToolInterface to register.

        Raises:
            ValueError: If a tool with the same name is already registered
                        or if the class doesn't implement ToolInterface correctly.
            TypeError: If the provided item is not a class or not a subclass
                       of ToolInterface.
        """
        if not isinstance(tool_class, type):
             raise TypeError(f"Expected a class, but got {type(tool_class)}")
        if not issubclass(tool_class, ToolInterface):
            raise TypeError(f"Tool class {tool_class.__name__} must inherit from ToolInterface.")

        try:
            definition_dict = tool_class.get_definition()
            # Basic validation of definition structure
            if not all(k in definition_dict for k in ["name", "description", "parameters"]):
                 raise ValueError("Tool definition must include 'name', 'description', and 'parameters'.")

            tool_name = definition_dict["name"]
            if not isinstance(tool_name, str) or not tool_name:
                raise ValueError("Tool definition 'name' must be a non-empty string.")

            if tool_name in _tool_registry:
                raise ValueError(f"Tool with name '{tool_name}' already registered.")

            # Create a ToolDefinition model instance for structured storage
            # Assuming interface_details can be derived or stored within definition
            tool_def_model = ToolDefinition(
                name=tool_name,
                description=definition_dict.get("description"),
                interface_details=definition_dict # Store the whole definition here for now
                # toolId will be generated by default
            )

            _tool_registry[tool_name] = tool_class
            _tool_definitions[tool_name] = tool_def_model
            print(f"Tool registered: {tool_name}") # Basic logging

        # Removed specific AbstractMethodError catch block;
        # issubclass check and Python's TypeError on instantiation handle this.
        except Exception as e:
            # Catch potential errors during get_definition() or validation
            raise ValueError(f"Failed to register tool {tool_class.__name__}: {e}")


    def get_tool_class(self, tool_name: str) -> Optional[Type[ToolInterface]]:
        """
        Retrieves the class for a registered tool by name.

        Args:
            tool_name: The name of the tool.

        Returns:
            The tool class if found, otherwise None.
        """
        return _tool_registry.get(tool_name)

    def get_tool_definition(self, tool_name: str) -> Optional[ToolDefinition]:
        """
        Retrieves the definition for a registered tool by name.

        Args:
            tool_name: The name of the tool.

        Returns:
            The ToolDefinition object if found, otherwise None.
        """
        return _tool_definitions.get(tool_name)

    def list_tool_definitions(self) -> list[ToolDefinition]:
        """Returns a list of definitions for all registered tools."""
        return list(_tool_definitions.values())

    def clear_all(self) -> None:
        """Clears the registry (useful for testing)."""
        _tool_registry.clear()
        _tool_definitions.clear()

# Singleton instance
tool_registry = ToolRegistry()

# Example: How a tool might be registered at startup
# from some_module import MyToolClass
# tool_registry.register_tool(MyToolClass)